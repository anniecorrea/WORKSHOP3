<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Modelo de Predicci√≥n de Felicidad</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.18.0/plotly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
        }

        .metric-icon {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .metric-label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .metric-subtext {
            font-size: 0.85em;
            color: #999;
            margin-top: 5px;
        }

        .chart-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .chart-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .filters {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 8px 16px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .filter-btn:hover {
            background: #667eea;
            color: white;
        }

        .filter-btn.active {
            background: #667eea;
            color: white;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: white;
            font-size: 1.2em;
        }

        .error {
            background: #ff6b6b;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        #worldMap {
            height: 500px;
        }

        .chart-canvas {
            max-height: 400px;
        }

        @media (max-width: 768px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåç Dashboard de Predicci√≥n de Felicidad Mundial</h1>
            <p>An√°lisis en Tiempo Real con Kafka & Machine Learning</p>
        </div>

        <div id="loading" class="loading">
            <p>‚è≥ Cargando datos desde happiness_db...</p>
        </div>

        <div id="errorMessage" class="error" style="display: none;"></div>

        <div id="dashboardContent" style="display: none;">
            <!-- M√©tricas Principales -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-icon">üìä</div>
                    <div class="metric-label">Total Registros</div>
                    <div class="metric-value" id="totalRecords">-</div>
                    <div class="metric-subtext">Train: <span id="trainRecords">-</span> | Test: <span id="testRecords">-</span></div>
                </div>

                <div class="metric-card">
                    <div class="metric-icon">üìà</div>
                    <div class="metric-label">R¬≤ (Coef. Determinaci√≥n)</div>
                    <div class="metric-value" id="r2Value">-</div>
                    <div class="metric-subtext">Train: <span id="r2Train">-</span> | Test: <span id="r2Test">-</span></div>
                </div>

                <div class="metric-card">
                    <div class="metric-icon">üìâ</div>
                    <div class="metric-label">MAE (Error Abs. Medio)</div>
                    <div class="metric-value" id="maeValue">-</div>
                    <div class="metric-subtext">Train: <span id="maeTrain">-</span> | Test: <span id="maeTest">-</span></div>
                </div>

                <div class="metric-card">
                    <div class="metric-icon">üìê</div>
                    <div class="metric-label">RMSE (Ra√≠z Error Cuad.)</div>
                    <div class="metric-value" id="rmseValue">-</div>
                    <div class="metric-subtext">Train: <span id="rmseTrain">-</span> | Test: <span id="rmseTest">-</span></div>
                </div>

                <div class="metric-card">
                    <div class="metric-icon">üåê</div>
                    <div class="metric-label">Pa√≠ses Analizados</div>
                    <div class="metric-value" id="countriesCount">-</div>
                    <div class="metric-subtext">Regiones: <span id="regionsCount">-</span></div>
                </div>

                <div class="metric-card">
                    <div class="metric-icon">üìÖ</div>
                    <div class="metric-label">Rango de A√±os</div>
                    <div class="metric-value" id="yearsRange">-</div>
                    <div class="metric-subtext">Total: <span id="yearsCount">-</span> a√±os</div>
                </div>
            </div>

            <!-- Mapa Mundial Interactivo -->
            <div class="chart-container">
                <div class="chart-header">
                    <div class="chart-title">üó∫Ô∏è Mapa Mundial de Predicciones</div>
                    <div class="filters">
                        <button class="filter-btn active" onclick="updateMapFilter('all')">Todos</button>
                        <button class="filter-btn" onclick="updateMapFilter('train')">Train</button>
                        <button class="filter-btn" onclick="updateMapFilter('test')">Test</button>
                    </div>
                </div>
                <div id="worldMap"></div>
            </div>

            <!-- Scatter Plot: Predicciones vs Reales -->
            <div class="chart-container">
                <div class="chart-header">
                    <div class="chart-title">üìä Valores Predichos vs Valores Reales</div>
                    <div class="filters">
                        <button class="filter-btn active" onclick="updateScatterFilter('all')">Todos</button>
                        <button class="filter-btn" onclick="updateScatterFilter('train')">Train</button>
                        <button class="filter-btn" onclick="updateScatterFilter('test')">Test</button>
                    </div>
                </div>
                <div id="scatterPlot"></div>
            </div>

            <div class="grid-2">
                <!-- Top 10 Pa√≠ses con Mayores Errores -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">üèÜ Top 10 Mayores Errores</div>
                    </div>
                    <canvas id="topErrorsChart" class="chart-canvas"></canvas>
                </div>

                <!-- Comparaci√≥n Train vs Test -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">‚öñÔ∏è Comparaci√≥n Train vs Test</div>
                    </div>
                    <canvas id="trainTestChart" class="chart-canvas"></canvas>
                </div>
            </div>

            <!-- Distribuci√≥n de Errores -->
            <div class="chart-container">
                <div class="chart-header">
                    <div class="chart-title">üìä Distribuci√≥n de Errores de Predicci√≥n</div>
                </div>
                <div id="errorDistribution"></div>
            </div>

            <div class="grid-2">
                <!-- Evoluci√≥n Temporal -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">üìà Evoluci√≥n Temporal</div>
                    </div>
                    <canvas id="temporalChart" class="chart-canvas"></canvas>
                </div>

                <!-- An√°lisis Regional -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">üåç An√°lisis por Regi√≥n</div>
                    </div>
                    <canvas id="regionalChart" class="chart-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Datos simulados (reemplazar con datos reales de la base de datos)
        let allData = [];
        let currentMapFilter = 'all';
        let currentScatterFilter = 'all';

        // Funci√≥n para generar datos de ejemplo
        function generateSampleData() {
            const countries = ['United States', 'Denmark', 'Switzerland', 'Iceland', 'Norway', 'Finland', 'Canada', 'Netherlands', 'Sweden', 'Australia', 'Israel', 'Costa Rica', 'Austria', 'Mexico', 'Brazil', 'Japan', 'Germany', 'France', 'United Kingdom', 'Spain', 'Italy', 'Greece', 'Poland', 'Czech Republic', 'Chile', 'Argentina', 'Colombia', 'Peru', 'Ecuador', 'Bolivia', 'Rwanda', 'Tanzania', 'Somalia', 'Syria', 'Botswana'];
            const regions = ['North America', 'Western Europe', 'Latin America', 'East Asia', 'Sub-Saharan Africa', 'Middle East'];
            const years = [2015, 2016, 2017, 2018, 2019];
            
            const data = [];
            let id = 1;
            
            countries.forEach(country => {
                years.forEach(year => {
                    const happiness = 3 + Math.random() * 5;
                    const predicted = happiness + (Math.random() - 0.5) * 1.5;
                    const split = Math.random() > 0.3 ? 'train' : 'test';
                    
                    data.push({
                        id: id++,
                        Country: country,
                        Region: regions[Math.floor(Math.random() * regions.length)],
                        Year: year,
                        GDP_per_Capita: 0.5 + Math.random() * 1.5,
                        Social_Support: 0.5 + Math.random() * 0.5,
                        Healthy_Life_Expectancy: 0.3 + Math.random() * 0.4,
                        Freedom: 0.2 + Math.random() * 0.6,
                        Generosity: -0.1 + Math.random() * 0.3,
                        Perceptions_of_Corruption: 0.05 + Math.random() * 0.4,
                        Happiness_Score: happiness,
                        Predicted_Score: predicted,
                        Predicted_Error: Math.abs(happiness - predicted),
                        Data_Split: split
                    });
                });
            });
            
            return data;
        }

        // Funci√≥n para calcular m√©tricas
        function calculateMetrics(data) {
            const train = data.filter(d => d.Data_Split === 'train');
            const test = data.filter(d => d.Data_Split === 'test');
            
            const calcR2 = (subset) => {
                const yMean = subset.reduce((sum, d) => sum + d.Happiness_Score, 0) / subset.length;
                const ssTotal = subset.reduce((sum, d) => sum + Math.pow(d.Happiness_Score - yMean, 2), 0);
                const ssRes = subset.reduce((sum, d) => sum + Math.pow(d.Happiness_Score - d.Predicted_Score, 2), 0);
                return 1 - (ssRes / ssTotal);
            };
            
            const calcMAE = (subset) => {
                return subset.reduce((sum, d) => sum + d.Predicted_Error, 0) / subset.length;
            };
            
            const calcRMSE = (subset) => {
                const mse = subset.reduce((sum, d) => sum + Math.pow(d.Predicted_Error, 2), 0) / subset.length;
                return Math.sqrt(mse);
            };
            
            return {
                total: data.length,
                train: train.length,
                test: test.length,
                r2: calcR2(data),
                r2Train: calcR2(train),
                r2Test: calcR2(test),
                mae: calcMAE(data),
                maeTrain: calcMAE(train),
                maeTest: calcMAE(test),
                rmse: calcRMSE(data),
                rmseTrain: calcRMSE(train),
                rmseTest: calcRMSE(test),
                countries: new Set(data.map(d => d.Country)).size,
                regions: new Set(data.map(d => d.Region)).size,
                years: [...new Set(data.map(d => d.Year))].sort()
            };
        }

        // Funci√≥n para actualizar m√©tricas en el dashboard
        function updateMetrics(metrics) {
            document.getElementById('totalRecords').textContent = metrics.total;
            document.getElementById('trainRecords').textContent = metrics.train;
            document.getElementById('testRecords').textContent = metrics.test;
            
            document.getElementById('r2Value').textContent = metrics.r2.toFixed(4);
            document.getElementById('r2Train').textContent = metrics.r2Train.toFixed(4);
            document.getElementById('r2Test').textContent = metrics.r2Test.toFixed(4);
            
            document.getElementById('maeValue').textContent = metrics.mae.toFixed(4);
            document.getElementById('maeTrain').textContent = metrics.maeTrain.toFixed(4);
            document.getElementById('maeTest').textContent = metrics.maeTest.toFixed(4);
            
            document.getElementById('rmseValue').textContent = metrics.rmse.toFixed(4);
            document.getElementById('rmseTrain').textContent = metrics.rmseTrain.toFixed(4);
            document.getElementById('rmseTest').textContent = metrics.rmseTest.toFixed(4);
            
            document.getElementById('countriesCount').textContent = metrics.countries;
            document.getElementById('regionsCount').textContent = metrics.regions;
            
            document.getElementById('yearsRange').textContent = 
                `${metrics.years[0]} - ${metrics.years[metrics.years.length - 1]}`;
            document.getElementById('yearsCount').textContent = metrics.years.length;
        }

        // Crear mapa mundial
        function createWorldMap(data, filter = 'all') {
            const filteredData = filter === 'all' ? data : data.filter(d => d.Data_Split === filter);
            
            const countryData = {};
            filteredData.forEach(d => {
                if (!countryData[d.Country]) {
                    countryData[d.Country] = {
                        happiness: [],
                        predicted: [],
                        error: []
                    };
                }
                countryData[d.Country].happiness.push(d.Happiness_Score);
                countryData[d.Country].predicted.push(d.Predicted_Score);
                countryData[d.Country].error.push(d.Predicted_Error);
            });
            
            const countries = Object.keys(countryData);
            const avgHappiness = countries.map(c => 
                countryData[c].happiness.reduce((a, b) => a + b, 0) / countryData[c].happiness.length
            );
            const avgError = countries.map(c =>
                countryData[c].error.reduce((a, b) => a + b, 0) / countryData[c].error.length
            );
            
            const trace = {
                type: 'choropleth',
                locations: countries,
                locationmode: 'country names',
                z: avgHappiness,
                text: countries.map((c, i) => 
                    `${c}<br>Felicidad: ${avgHappiness[i].toFixed(2)}<br>Error: ${avgError[i].toFixed(3)}`
                ),
                colorscale: [
                    [0, '#ff6b6b'],
                    [0.5, '#feca57'],
                    [1, '#48dbfb']
                ],
                colorbar: {
                    title: 'Happiness Score'
                }
            };
            
            const layout = {
                geo: {
                    projection: {
                        type: 'natural earth'
                    }
                },
                margin: { t: 0, b: 0, l: 0, r: 0 },
                height: 500
            };
            
            Plotly.newPlot('worldMap', [trace], layout, {responsive: true});
        }

        // Crear scatter plot
        function createScatterPlot(data, filter = 'all') {
            const filteredData = filter === 'all' ? data : data.filter(d => d.Data_Split === filter);
            
            const trainData = filteredData.filter(d => d.Data_Split === 'train');
            const testData = filteredData.filter(d => d.Data_Split === 'test');
            
            const traces = [];
            
            if (filter === 'all' || filter === 'train') {
                traces.push({
                    x: trainData.map(d => d.Happiness_Score),
                    y: trainData.map(d => d.Predicted_Score),
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Train',
                    marker: {
                        color: '#4CAF50',
                        size: 8,
                        opacity: 0.6
                    },
                    text: trainData.map(d => `${d.Country} (${d.Year})`),
                    hovertemplate: '%{text}<br>Real: %{x:.2f}<br>Predicho: %{y:.2f}<extra></extra>'
                });
            }
            
            if (filter === 'all' || filter === 'test') {
                traces.push({
                    x: testData.map(d => d.Happiness_Score),
                    y: testData.map(d => d.Predicted_Score),
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Test',
                    marker: {
                        color: '#FF9800',
                        size: 8,
                        opacity: 0.6
                    },
                    text: testData.map(d => `${d.Country} (${d.Year})`),
                    hovertemplate: '%{text}<br>Real: %{x:.2f}<br>Predicho: %{y:.2f}<extra></extra>'
                });
            }
            
            // L√≠nea de predicci√≥n perfecta
            traces.push({
                x: [2, 8],
                y: [2, 8],
                mode: 'lines',
                name: 'Predicci√≥n Perfecta',
                line: {
                    color: 'red',
                    dash: 'dash',
                    width: 2
                }
            });
            
            const layout = {
                xaxis: { title: 'Felicidad Real' },
                yaxis: { title: 'Felicidad Predicha' },
                hovermode: 'closest',
                showlegend: true,
                height: 500,
                margin: { t: 30, b: 50, l: 60, r: 30 }
            };
            
            Plotly.newPlot('scatterPlot', traces, layout, {responsive: true});
        }

        // Top 10 errores
        function createTopErrorsChart(data) {
            const countryErrors = {};
            data.forEach(d => {
                if (!countryErrors[d.Country]) {
                    countryErrors[d.Country] = { train: [], test: [] };
                }
                countryErrors[d.Country][d.Data_Split].push(d.Predicted_Error);
            });
            
            const avgErrors = Object.keys(countryErrors).map(country => ({
                country,
                trainError: countryErrors[country].train.length > 0 
                    ? countryErrors[country].train.reduce((a, b) => a + b, 0) / countryErrors[country].train.length 
                    : 0,
                testError: countryErrors[country].test.length > 0
                    ? countryErrors[country].test.reduce((a, b) => a + b, 0) / countryErrors[country].test.length
                    : 0,
                totalError: [...countryErrors[country].train, ...countryErrors[country].test]
                    .reduce((a, b) => a + b, 0) / 
                    (countryErrors[country].train.length + countryErrors[country].test.length)
            }));
            
            avgErrors.sort((a, b) => b.totalError - a.totalError);
            const top10 = avgErrors.slice(0, 10);
            
            const ctx = document.getElementById('topErrorsChart').getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: top10.map(d => d.country),
                    datasets: [
                        {
                            label: 'Train',
                            data: top10.map(d => d.trainError),
                            backgroundColor: '#4CAF50'
                        },
                        {
                            label: 'Test',
                            data: top10.map(d => d.testError),
                            backgroundColor: '#FF9800'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Error de Predicci√≥n' }
                        }
                    }
                }
            });
        }

        // Comparaci√≥n Train vs Test
        function createTrainTestChart(metrics) {
            const ctx = document.getElementById('trainTestChart').getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Train', 'Test'],
                    datasets: [
                        {
                            label: 'MAE',
                            data: [metrics.maeTrain, metrics.maeTest],
                            backgroundColor: '#2196F3'
                        },
                        {
                            label: 'RMSE',
                            data: [metrics.rmseTrain, metrics.rmseTest],
                            backgroundColor: '#f44336'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Valor de M√©trica' }
                        }
                    }
                }
            });
        }

        // Distribuci√≥n de errores
        function createErrorDistribution(data) {
            const trainErrors = data.filter(d => d.Data_Split === 'train').map(d => d.Predicted_Error);
            const testErrors = data.filter(d => d.Data_Split === 'test').map(d => d.Predicted_Error);
            
            const trace1 = {
                x: trainErrors,
                type: 'histogram',
                name: 'Train',
                opacity: 0.7,
                marker: { color: '#4CAF50' },
                nbinsx: 30
            };
            
            const trace2 = {
                x: testErrors,
                type: 'histogram',
                name: 'Test',
                opacity: 0.7,
                marker: { color: '#FF9800' },
                nbinsx: 30
            };
            
            const mae = data.reduce((sum, d) => sum + d.Predicted_Error, 0) / data.length;
            
            const trace3 = {
                x: [mae, mae],
                y: [0, 100],
                mode: 'lines',
                name: `MAE = ${mae.toFixed(2)}`,
                line: {
                    color: 'red',
                    dash: 'dash',
                    width: 2
                }
            };
            
            const layout = {
                barmode: 'overlay',
                xaxis: { title: 'Error de Predicci√≥n (absoluto)' },
                yaxis: { title: 'Frecuencia' },
                showlegend: true,
                height: 400,
                margin: { t: 30, b: 50, l: 60, r: 30 }
            };
            
            Plotly.newPlot('errorDistribution', [trace1, trace2, trace3], layout, {responsive: true});
        }

        // Evoluci√≥n temporal
        function createTemporalChart(data) {
            const yearlyData = {};
            data.forEach(d => {
                if (!yearlyData[d.Year]) {
                    yearlyData[d.Year] = { actual: [], predicted: [] };
                }
                yearlyData[d.Year].actual.push(d.Happiness_Score);
                yearlyData[d.Year].predicted.push(d.Predicted_Score);
            });
            
            const years = Object.keys(yearlyData).sort();
            const avgActual = years.map(y => 
                yearlyData[y].actual.reduce((a, b) => a + b, 0) / yearlyData[y].actual.length
            );
            const avgPredicted = years.map(y =>
                yearlyData[y].predicted.reduce((a, b) => a + b, 0) / yearlyData[y].predicted.length
            );
            
            const ctx = document.getElementById('temporalChart').getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: years,
                    datasets: [
                        {
                            label: 'Felicidad Real',
                            data: avgActual,
                            borderColor: '#2196F3',
                            backgroundColor: 'rgba(33, 150, 243, 0.1)',
                            fill: true
                        },
                        {
                            label: 'Felicidad Predicha',
                            data: avgPredicted,
                            borderColor: '#FF9800',
                            backgroundColor: 'rgba(255, 152, 0, 0.1)',
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: { display: true, text: 'Happiness Score' },
                            min: 3,
                            max: 8
                        },
                        x: {
                            title: { display: true, text: 'A√±o' }
                        }
                    }
                }
            });
        }

        // An√°lisis regional
        function createRegionalChart(data) {
            const regionalData = {};
            data.forEach(d => {
                if (!regionalData[d.Region]) {
                    regionalData[d.Region] = { errors: [], count: 0 };
                }
                regionalData[d.Region].errors.push(d.Predicted_Error);
                regionalData[d.Region].count++;
            });
            
            const regions = Object.keys(regionalData);
            const avgErrors = regions.map(r =>
                regionalData[r].errors.reduce((a, b) => a + b, 0) / regionalData[r].errors.length
            );
            
            const ctx = document.getElementById('regionalChart').getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: regions,
                    datasets: [{
                        label: 'Error Promedio',
                        data: avgErrors,
                        backgroundColor: [
                            '#FF6384',
                            '#36A2EB',
                            '#FFCE56',
                            '#4BC0C0',
                            '#9966FF',
                            '#FF9F40'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: { display: true, text: 'Error de Predicci√≥n' }
                        }
                    }
                }
            });
        }

        // Funciones de filtro
        function updateMapFilter(filter) {
            currentMapFilter = filter;
            document.querySelectorAll('#worldMap').forEach(el => {
                el.closest('.chart-container').querySelectorAll('.filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
            });
            event.target.classList.add('active');
            createWorldMap(allData, filter);
        }

        function updateScatterFilter(filter) {
            currentScatterFilter = filter;
            document.querySelectorAll('#scatterPlot').forEach(el => {
                el.closest('.chart-container').querySelectorAll('.filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
            });
            event.target.classList.add('active');
            createScatterPlot(allData, filter);
        }

        // Inicializar dashboard
        async function initDashboard() {
            try {
                // NOTA: Aqu√≠ debes reemplazar con la llamada real a tu API/base de datos
                // Ejemplo de endpoint: const response = await fetch('/api/predicciones');
                // const data = await response.json();
                
                // Por ahora usamos datos simulados
                // Cargar datos reales desde la API
                const response = await fetch('http://127.0.0.1:3000/api/predicciones');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                allData = await response.json();
                
                const metrics = calculateMetrics(allData);
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('dashboardContent').style.display = 'block';
                
                updateMetrics(metrics);
                createWorldMap(allData);
                createScatterPlot(allData);
                createTopErrorsChart(allData);
                createTrainTestChart(metrics);
                createErrorDistribution(allData);
                createTemporalChart(allData);
                createRegionalChart(allData);
                
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('errorMessage').style.display = 'block';
                document.getElementById('errorMessage').textContent = 
                    '‚ùå Error al cargar los datos: ' + error.message;
                console.error('Error:', error);
            }
        }

        // Cargar datos al iniciar
        window.addEventListener('load', initDashboard);

        // Actualizar cada 30 segundos (opcional, para datos en tiempo real)
        // setInterval(initDashboard, 30000);
    </script>
</body>
</html>